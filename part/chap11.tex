\chapter{Advanced DP}\label{chap:AdvancedDP}
\section{Advanced Linear DP}
\subsection{Two-pass grid collection problem}
In this case we run DP on two different roads at the same time:
\begin{lstlisting}
const int N = 15;
int n, w[N][N], f[N * 2][N][N];
int main()
{
  cin >> n;
  // INPUT w[N][N]
  for (int k = 2; k <= n * 2; k++)
  for (int i1 = 1; i1 <= k; i1++)
    for (int i2 = 1; i2 <= k; i2++)
    {
      int j1 = k - i1, j2 = k - i2;
      int t = w[i1][j1];
      if (i1 != i2) t += w[i2][j2];
      int &x = f[k][i1][i2];
      x = max(x, f[k - 1][i1 - 1][i2 - 1] + t);
      x = max(x, f[k - 1][i1 - 1][i2] + t);
      x = max(x, f[k - 1][i1][i2 - 1] + t);
      x = max(x, f[k - 1][i1][i2] + t);
    }
  cout << f[n * 2][n][n] << '\n';
  return 0;
}
\end{lstlisting}
\section{Advanced LIS}
\subsection{Longest Bitonic Subsequence}
\begin{lstlisting}
const int N = 1010;
int n, a[N], f[N], g[N];
int main()
{
  cin >> n;
  for (int i = 1; i <= n; i++)
  cin >> a[i];
  for (int i = 1; i <= n; i++)
  {
  f[i] = 1;
  for (int j = 1; j < i; j++)
    if (a[i] > a[j])
      f[i] = max(f[i], f[j] + 1);
  }
  for (int i = n; i >= 1; i--)
  {
  g[i] = 1;
  for (int j = n; j > i; j--)
    if (a[i] > a[j])
      g[i] = max(g[i], g[j] + 1);
  }
  int ans = 0;
  for (int i = 1; i <= n; i++)
  ans = max(ans, g[i] + f[i] - 1);
  cout << ans << '\n';
  return 0;
}
\end{lstlisting}
\subsection{MSIS}
MSIS means Maximum Sum Increasing Subsequence
\begin{lstlisting}
const int N = 1010;
int n, w[N], f[N];
int main()
{
  cin >> n;
  for (int i = 0; i < n; i++) cin >> w[i];
  int res = 0;
  for (int i = 0; i < n; i++)
  {
      f[i] = w[i];
      for (int j = 0; j < i; j++)
          if (w[i] > w[j])
              f[i] = max(f[i], f[j] + w[i]);
      res = max(res, f[i]);
  }
  cout << res;
}
\end{lstlisting}
\subsection{LCIS}
LCIS means Longest Common Increasing Subsequence
\begin{lstlisting}
const int N = 3010;
int n, a[N], b[N], f[N][N];
int main()
{
  cin >> n;
  for (int i = 1; i <= n; i++)
      cin >> a[i];
  for (int i = 1; i <= n; i++)
      cin >> b[i];
  for (int i = 1; i <= n; i++)
  {
      int maxv = 1;
      for (int j = 1; j <= n; j++)
      {
          f[i][j] = f[i - 1][j];
          if (a[i] == b[j])
              f[i][j] = max(f[i][j], maxv);
          if (a[i] > b[j])
              maxv = max(maxv, f[i - 1][j] + 1);
      }
  }
  int res = 0;
  for (int i = 1; i <= n; i++)
      res = max(res, f[n][i]);
  cout << res;
}
\end{lstlisting}
\section{Knapsack Problem}
\subsection{How To Initialize}
Initialization for Counting the Number of Solutions:
\begin{itemize}
    \item \textbf{2D Case}:
    \begin{itemize}
      \item When volume is at most $j$: \texttt{f[0][i] = 1} for $0 \leq i \leq m$, others are 0
      \item When volume is exactly $j$: \texttt{f[0][0] = 1}, others are 0
      \item When volume is at least $j$: \texttt{f[0][0] = 1}, others are 0
    \end{itemize}
    
    \item \textbf{1D Case}:
    \begin{itemize}
      \item When volume is at most $j$: \texttt{f[i] = 1} for $0 \leq i \leq m$
      \item When volume is exactly $j$: \texttt{f[0] = 1}, others are 0
      \item When volume is at least $j$: \texttt{f[0] = 1}, others are 0
    \end{itemize}
\end{itemize}
Initialization for Finding Maximum or Minimum Value:
\begin{itemize}
    \item \textbf{2D Case}:
    \begin{itemize}
      \item When volume is at most $j$: \texttt{f[i][k] = 0} for $0 \leq i \leq n$, $0 \leq k \leq m$ (only for maximizing value)
      \item When volume is exactly $j$:
      \begin{itemize}
        \item For minimizing value: \texttt{f[0][0] = 0}, others are \texttt{INF}
        \item For maximizing value: \texttt{f[0][0] = 0}, others are \texttt{-INF}
      \end{itemize}
      \item When volume is at least $j$: \texttt{f[0][0] = 0}, others are \texttt{INF} (only for minimizing value)
    \end{itemize}

    \item \textbf{1D Case}:
    \begin{itemize}
      \item When volume is at most $j$: \texttt{f[i] = 0} for $0 \leq i \leq m$ (only for maximizing value)
      \item When volume is exactly $j$:
      \begin{itemize}
        \item For minimizing value: \texttt{f[0] = 0}, others are \texttt{INF}
        \item For maximizing value: \texttt{f[0] = 0}, others are \texttt{-INF}
      \end{itemize}
      \item When volume is at least $j$: \texttt{f[0] = 0}, others are \texttt{INF} (only for minimizing value)
    \end{itemize}
\end{itemize}
\subsection{Multiple Knapsack Problem}
\begin{lstlisting}
const int M = 20010;
int n, m, v, w, s;
int f[M], g[M], q[M];
int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
  {
    cin >> v >> w >> s;
    memcpy(g, f, sizeof g);
    for (int r = 0; r < v; r++)
    {
      int hh = 0, tt = -1;
      for (int j = r; j <= m; j += v)
      {
        while (hh <= tt && j - s * v > q[hh])
          hh++;
        while (hh <= tt && g[q[tt]] + (j - q[tt]) / v * w <= g[j])
          tt--;
        q[++tt] = j;
        f[j] = g[q[hh]] + (j - q[hh]) / v * w;
      }
    }
  }
  cout << f[m];
}
\end{lstlisting}
\subsection{Two-Dimensional Cost Knapsack Problem}
\begin{lstlisting}
const int N = 110;
int n, V, M, f[N][N];
int main()
{
  cin >> n >> V >> M;
  for (int i = 0; i < n; i++)
  {
      int v, m, w;
      cin >> v >> m >> w;
      for (int j = V; j >= v; j--)
          for (int k = M; k >= m; k--)
              f[j][k] = max(f[j][k], f[j - v][k - m] + w);
  }
  cout << f[V][M] << '\n';
}
\end{lstlisting}
\subsection{Finding the Actual Solution Set}
\begin{lstlisting}
const int N = 1010;
int n, m;
int v[N], w[N], f[N][N];
int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
      cin >> v[i] >> w[i];
  for (int i = n; i >= 1; i--)
      for (int j = 0; j <= m; j++)
      {
          f[i][j] = f[i + 1][j];
          if (j >= v[i])
              f[i][j] = max(f[i][j], f[i + 1][j - v[i]] + w[i]);
      }
  int j = m;
  for (int i = 1; i <= n; i++)
      if (j >= v[i] && f[i][j] == f[i + 1][j - v[i]] + w[i])
      {
          cout << i << ' ';
          j -= v[i];
      }
}
\end{lstlisting}
\subsection{Maximum Linearly Independent Subset}
\begin{lstlisting}
const int N = 110, M = 25010;
int n, v[N];
bool f[M];
int main()
{
  int T; cin >> T;
  while (T--)
  {
      cin >> n;
      for (int i = 1; i <= n; ++i)
          cin >> v[i];
      sort(v + 1, v + n + 1);
      int m = v[n], res = 0;
      memset(f, 0, sizeof f);
      f[0] = true;
      for (int i = 1; i <= n; ++i)
      {
          if (f[v[i]]) continue;
          res++;
          for (int j = v[i]; j <= m; ++j)
              f[j] |= f[j - v[i]];
      }
      cout << res << '\n';
  }
}
\end{lstlisting}
\subsection{Mixed Knapsack Problem}
\begin{lstlisting}
const int N = 1010;
int n, m, f[N];
int main()
{
  cin >> n >> m;
  for (int i = 0; i < n; i++)
  {
      int v, w, s;
      cin >> v >> w >> s;
      if (!s)
      {
          for (int j = v; j <= m; j++)
              f[j] = max(f[j], f[j - v] + w);
      }
      else
      {
          if (s == -1) s = 1;
          for (int k = 1; k <= s; k *= 2)
          {
              for (int j = m; j >= k * v; j--)
                  f[j] = max(f[j], f[j - k * v] + k * w);
              s -= k;
          }
          if (s)
          {
              for (int j = m; j >= s * v; j--)
                  f[j] = max(f[j], f[j - s * v] + s * w);
          }
      }
  }
  cout << f[m] << '\n';
}
\end{lstlisting}
\subsection{Dependent Knapsack Problem}
\begin{lstlisting}
const int N = 110;
int n, m, root;
int h[N], e[N], ne[N], idx;
int v[N], w[N], [N][N];
void add(int a, int b)
{
  e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void dfs(int u)
{
  for (int i = h[u]; ~i; i = ne[i])
  {
      int son = e[i];
      dfs(son);
      for (int j = m - v[u]; j >= 0; --j)
          for (int k = 0; k <= j; ++k)
              f[u][j] = max(f[u][j], f[u][j - k] + f[son][k]);
  }
  for (int j = m; j >= v[u]; --j)
      f[u][j] = f[u][j - v[u]] + w[u];
  for (int j = 0; j < v[u]; ++j)
      f[u][j] = 0;
}
int main()
{
  memset(h, -1, sizeof h);
  cin >> n >> m;
  for (int i = 1; i <= n; ++i)
  {
      int p;
      cin >> v[i] >> w[i] >> p;
      if (p == -1) root = i;
      else add(p, i);
  }
  dfs(root);
  cout << f[root][m] << '\n';
}
\end{lstlisting}
\subsection{Number of Solutions}
\begin{lstlisting}
const int N = 1010, mod = 1e9 + 7;
int n, m;
int w[N], v[N], f[N], g[N];
int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; ++i)
      cin >> v[i] >> w[i];
  g[0] = 1;
  for (int i = 1; i <= n; ++i)
  {
      for (int j = m; j >= v[i]; --j)
      {
          int temp = max(f[j], f[j - v[i]] + w[i]), c = 0;
          if (temp == f[j])
              c = (c + g[j]) % mod;
          if (temp == f[j - v[i]] + w[i])
              c = (c + g[j - v[i]]) % mod;
          f[j] = temp, g[j] = c;
      }
  }
  int res = 0;
  for (int j = 0; j <= m; ++j)
      if (f[j] == f[m])
          res = (res + g[j]) % mod;
  cout << res << '\n';
}
\end{lstlisting}
\section{FSM}
\subsection{Common FSM}
\begin{lstlisting}
const int N = 100010;
int n, w[N], f[N][2];
int main()
{
  int T; cin >> T;
  while (T--)
  {
      cin >> n;
      for (int i = 1; i <= n; i++)
          cin >> w[i];
      for (int i = 1; i <= n; i++)
      {
          // YOUR_FSM_RULES
          // f[i][0] =
          // f[i][1] =
      }
      cout << max(f[n][0], f[n][1]) << '\n';
  }
}
\end{lstlisting}
\subsection{Linear DP + KMP}
\begin{lstlisting}
const int N = 55, mod = 1e9 + 7
int n, m, f[N][N], ne[N];
char s[N];
int main()
{
  cin >> n >> s + 1;
  m = strlen(s + 1);
  for (int i = 2, j = 0; i <= m; i++)
  {
    while (j && s[i] != s[j + 1])
      j = ne[j];
    if (s[j + 1] == s[i]) j++;
    ne[i] = j;
  }
  f[0][0] = 1;
  for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
      for (char ch = 'a'; ch <= 'z'; ch++)
      {
        int ptr = j;
        while (ptr && s[ptr + 1] != ch)
          ptr = ne[ptr];
        if (s[ptr + 1] == ch) ptr++;
        f[i + 1][ptr] = (f[i + 1][ptr] + f[i][j]) % mod;
      }
  int res = 0;
  for (int j = 0; j < m; j++)
    res = (res + f[n][j]) % mod;
  cout << res;
}
\end{lstlisting}
\subsection{Linear DP + AC Automaton}
\begin{lstlisting}
const int N = 1010, INF = 0x3f3f3f3f;
int n, m, T = 1, f[N][N];
int tr[N][4], dar[N], idx;
int q[N], ne[N];
char str[N];
int get(char c)
{
  if (c == 'A') return 0;
  if (c == 'T') return 1;
  if (c == 'G') return 2;
  return 3;
}
void insert()
{
  int p = 0;
  for (int i = 0; str[i]; i++)
  {
    int t = get(str[i]);
    if (tr[p][t] == 0)
      tr[p][t] = ++idx;
    p = tr[p][t];
  }
  dar[p] = 1;
}
void build()
{
  int hh = 0, tt = -1;
  for (int i = 0; i < 4; i++)
    if (tr[0][i])
      q[++tt] = tr[0][i];
  while (hh <= tt)
  {
    int t = q[hh++];
    for (int i = 0; i < 4; i++)
    {
      int p = tr[t][i];
      if (!p)
        tr[t][i] = tr[ne[t]][i];
      else
      {
        ne[p] = tr[ne[t]][i];
        q[++tt] = p;
        dar[p] |= dar[ne[p]];
      }
    }
  }
}
int main()
{
  int T = 1;
  while (cin >> n, n)
  {
    memset(tr, 0, sizeof tr);
    memset(dar, 0, sizeof dar);
    memset(ne, 0, sizeof ne);
    idx = 0;
    for (int i = 0; i < n; i++)
    {
      cin >> str;
      insert();
    }
    build();
    cin >> (str + 1);
    m = strlen(str + 1);
    memset(f, 0x3f, sizeof f);
    f[0][0] = 0;
    for (int i = 0; i < m; i++)
      for (int j = 0; j <= idx; j++)
        for (int k = 0; k < 4; k++)
        {
          int t = get(str[i + 1]) != k;
          int p = tr[j][k];
          if (!dar[p])
            f[i + 1][p] = min(f[i + 1][p], f[i][j] + t);
        }
    int res = INF;
    for (int i = 0; i <= idx; i++)
      res = min(res, f[m][i]);
    if (res == INF) res = -1;
    cout << "Case " << T++ 
    << ": " << res << '\n';
  }
}
\end{lstlisting}
\section{State Compression DP}
\subsection{Bitmask DP \& Rolling Array \& Target-State Optimization}
\begin{lstlisting}
const int N = 12, M = 1 << 10, K = 110;
int n, m, cnt[M];
vector<int> state, head[M];
LL f[N][K][M];
bool check(int state)
{
  for (int i = 0; i < n; i++)
    if ((state >> i & 1) && (state >> i + 1 & 1))
      return false;
  return true;
}
int count(int state)
{
  int res = 0;
  for (int i = 0; i < n; i++)
    res += state >> i & 1;
  return res;
}
int main()
{
  cin >> n >> m;
  for (int i = 0; i < 1 << n; i++)
    if (check(i))
    {
      state.push_back(i);
      cnt[i] = count(i);
    }
  for (int i = 0; i < state.size(); i++)
    for (int j = 0; j < state.size(); j++)
    {
      int a = state[i], b = state[j];
      if ((a & b) == 0 && check(a | b))
        head[i].push_back(j);
    }
  f[0][0][0] = 1;
  for (int i = 1; i <= n + 1; i++)
    for (int j = 0; j <= m; j++)
      for (int a = 0; a < state.size(); a++)
        for (int b : head[a])
        {
          int c = cnt[state[a]];
          if (j >= c)
            f[i][j][a] += f[i - 1][j - c][b];
        }
  cout << f[n + 1][m][0];
}
\end{lstlisting}
\subsection{Bitmask DP \& Transfer Optimization}
\begin{lstlisting}
const int N = 10, M = 1 << 10;
int n, m, g[1010], cnt[M];
int f[2][M][M];
vector<int> state;
bool check(int state)
{
  for (int i = 0; i < m; i++)
    if ((state >> i & 1) && ((state >> i + 1 & 1) || (state >> i + 2 & 1)))
      return false;
  return true;
}
int count(int state)
{
  int res = 0;
  for (int i = 0; i < m; i++)
    if (state >> i & 1) res++;
  return res;
}
int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
    for (int j = 0; j < m; j++)
    {
      char c;
      cin >> c;
      g[i] += (c == 'H') << j;
    }
  for (int i = 0; i < 1 << m; i++)
    if (check(i))
    {
      state.push_back(i);
      cnt[i] = count(i);
    }
  for (int i = 1; i <= n; i++)
    for (int j = 0; j < state.size(); j++)
      for (int k = 0; k < state.size(); k++)
        for (int u = 0; u < state.size(); u++)
        {
          int a = state[j], b = state[k], c = state[u];
          if (a & b | a & c | b & c)
            continue;
          if (g[i] & b | g[i - 1] & a)
            continue;
          f[i & 1][j][k] = max(f[i & 1][j][k], f[i - 1 & 1][u][j] + cnt[b]);
        }
  int res = 0;
  for (int i = 0; i < state.size(); i++)
    for (int j = 0; j < state.size(); j++)
      res = max(res, f[n & 1][i][j]);
  cout << res;
}
\end{lstlisting}
\subsection{Bitmask DP \& Repeated Coverage Problem}
\begin{lstlisting}
const double eps = 1e-8;
const int N = 20, M = 1 << N;
int n, m, T, path[N][N], f[M]
PDD ver[N];
int cmp_lf(double a, double b)
{
  if (fabs(a - b) < eps) return 0;
  if (a > b) return 1;
  return -1;
}
void init_path()
{
  memset(path, 0, sizeof path);
  for (int i = 0; i < n; i++)
  {
    path[i][i] = 1 << i;
    for (int j = 0; j < n; j++)
    {
      double x1 = ver[i].x, y1 = ver[i].y;
      double x2 = ver[j].x, y2 = ver[j].y;
      if (!cmp_lf(x1, x2)) continue;
      double a = (y1 / x1 - y2 / x2) / (x1 - x2);
      double b = (y1 / x1) - a * x1;
      if (cmp_lf(a, 0.0) >= 0)
        continue;
      for (int k = 0; k < n; k++)
      {
        double x = ver[k].x, y = ver[k].y;
        if (!cmp_lf(y, a * x * x + b * x))
          path[i][j] += 1 << k;
      }
    }
  }
}
void solve()
{
  cin >> n >> m;
  for (int i = 0; i < n; i++)
    cin >> ver[i].x >> ver[i].y;
  init_path();
  memset(f, 0x3f, sizeof f);
  f[0] = 0;
  for (int cur_st = 0; cur_st + 1 < 1 << n; cur_st++)
  {
    int t = -1;
    for (int i = 0; i < n; i++)
      if (!(cur_st >> i & 1)) t = i;
    for (int i = 0; i < n; i++)
    {
      int ne_st = path[t][i] | cur_st;
      f[ne_st] = min(f[ne_st], f[cur_st] + 1);
    }
  }
  cout << f[(1 << n) - 1] << '\n';
}
int main()
{
  cin >> T;
  while (T--) solve();
}
\end{lstlisting}
\subsection{Bitmask DP \& MST}
\begin{lstlisting}
const int N = 12, M = 1 << N;
int n, m, d[N][N], f[M][N], g[M];
int main()
{
  cin >> n >> m;
  memset(d, 0x3f, sizeof d);
  for (int i = 0; i < n; i++)
    d[i][i] = 0;
  while (m--)
  {
    int a, b, c;
    cin >> a >> b >> c;
    a--, b--;
    d[a][b] = d[b][a] = min(d[a][b], c);
  }
  for (int i = 1; i < 1 << n; i++)
    for (int j = 0; j < n; j++)
      if (i >> j & 1)
        for (int k = 0; k < n; k++)
          if (d[j][k] != INF)
            g[i] |= 1 << k;
  memset(f, 0x3f, sizeof f);
  for (int i = 0; i < n; i++)
    f[1 << i][0] = 0;
  for (int i = 1; i < 1 << n; i++)
    for (int j = (i - 1); j; j = (j - 1) & i)
      if ((g[j] & i) == i)
      {
        int remain = i ^ j;
        int cost = 0;
        for (int k = 0; k < n; k++)
          if (remain >> k & 1)
          {
            int t = INF;
            for (int u = 0; u < n; u++)
              if (j >> u & 1)
                t = min(t, d[k][u]);
            cost += t;
          }
        for (int k = 1; k < n; k++)
          f[i][k] = min(f[i][k], f[j][k - 1] + cost * k);
      }
  int res = INF;
  for (int i = 0; i < n; i++)
    res = min(res, f[(1 << n) - 1][i]);
  cout << res;
}
\end{lstlisting}
\section{Digit DP}
\begin{lstlisting}
const int N = 35;
int l, r, k, b, a[N], al, f[N][N];
int dp(int pos, int st, int op)
{
  if (!pos) return st == k;
  if (!op && ~f[pos][st])
      return f[pos][st];
  int res = 0, maxx = op ? min(a[pos], 1) : 1;
  for (int i = 0; i <= maxx; i++)
  {
      if (st + i > k) continue;
      res += dp(pos - 1, st + i, op && i == a[pos]);
  }
  return op ? res : f[pos][st] = res;
}
int calc(int x)
{
  al = 0;
  memset(f, -1, sizeof f);
  while (x) a[++al] = x % b, x /= b;
  return dp(al, 0, 1);
}
int main()
{
  cin >> l >> r >> k >> b;
  cout << calc(r) - calc(l - 1) << '\n';
}
\end{lstlisting}
\section{Queue Optimization for DP}
\begin{lstlisting}
int n, m, s[300010], q[300010];
int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; i++)
      cin >> s[i], s[i] += s[i - 1];
  int res = INT_MIN, hh = 0, tt = 0;
  for (int i = 1; i <= n; i++)
  {
      if (q[hh] < i - m) hh++;
      res = max(res, s[i] - s[q[hh]]);
      while (hh <= tt && s[q[tt]] >= s[i]) tt--;
      q[++tt] = i;
  }
}
\end{lstlisting}
